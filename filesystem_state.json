{"file_contents":{"components/ThemedView.tsx":{"content":"import { View, type ViewProps } from \"react-native\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\n\nexport type ThemedViewProps = ViewProps & {\n  lightColor?: string;\n  darkColor?: string;\n};\n\nexport function ThemedView({\n  style,\n  lightColor,\n  darkColor,\n  ...otherProps\n}: ThemedViewProps) {\n  const { theme, isDark } = useTheme();\n\n  const backgroundColor =\n    isDark && darkColor\n      ? darkColor\n      : !isDark && lightColor\n        ? lightColor\n        : theme.backgroundRoot;\n\n  return <View style={[{ backgroundColor }, style]} {...otherProps} />;\n}\n","size_bytes":563},"components/HeaderTitle.tsx":{"content":"import React from \"react\";\nimport { View, StyleSheet, Image } from \"react-native\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { Spacing } from \"@/constants/theme\";\n\ninterface HeaderTitleProps {\n  title: string;\n}\n\nexport function HeaderTitle({ title }: HeaderTitleProps) {\n  return (\n    <View style={styles.container}>\n      <Image\n        source={require(\"../assets/images/icon.png\")}\n        style={styles.icon}\n        resizeMode=\"contain\"\n      />\n      <ThemedText style={styles.title}>{title}</ThemedText>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"flex-start\",\n  },\n  icon: {\n    width: 28,\n    height: 28,\n    marginRight: Spacing.sm,\n  },\n  title: {\n    fontSize: 17,\n    fontWeight: \"600\",\n  },\n});\n","size_bytes":829},"hooks/useColorScheme.web.ts":{"content":"import { useEffect, useState } from \"react\";\nimport { useColorScheme as useRNColorScheme } from \"react-native\";\n\n/**\n * To support static rendering, this value needs to be re-calculated on the client side for web\n */\nexport function useColorScheme() {\n  const [hasHydrated, setHasHydrated] = useState(false);\n\n  useEffect(() => {\n    setHasHydrated(true);\n  }, []);\n\n  const colorScheme = useRNColorScheme();\n\n  if (hasHydrated) {\n    return colorScheme;\n  }\n\n  return \"light\";\n}\n","size_bytes":480},"screens/SettingsScreen.tsx":{"content":"import { useState, useEffect } from \"react\";\nimport { View, StyleSheet, Text, Switch, Pressable } from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { Colors, Spacing } from \"@/constants/theme\";\nimport { ScreenScrollView } from \"@/components/ScreenScrollView\";\nimport {\n  loadSettings,\n  saveSettings,\n  type CameraSettings,\n  type Resolution,\n  type TimestampColor,\n} from \"@/utils/settings\";\nimport { formatTimestamp } from \"@/utils/photoProcessing\";\n\nexport default function SettingsScreen() {\n  const [settings, setSettings] = useState<CameraSettings | null>(null);\n\n  useEffect(() => {\n    loadSettings().then(setSettings);\n  }, []);\n\n  const updateSetting = async <K extends keyof CameraSettings>(\n    key: K,\n    value: CameraSettings[K]\n  ) => {\n    if (!settings) return;\n    const updated = { ...settings, [key]: value };\n    setSettings(updated);\n    await saveSettings(updated);\n  };\n\n  if (!settings) {\n    return <View style={styles.container} />;\n  }\n\n  return (\n    <ScreenScrollView style={styles.container}>\n      <View style={styles.section}>\n        <Text style={styles.sectionTitle}>Image Settings</Text>\n\n        <View style={styles.settingRow}>\n          <Text style={styles.label}>Resolution</Text>\n          <View style={styles.segmentedControl}>\n            <Pressable\n              style={({ pressed }) => [\n                styles.segment,\n                settings.resolution === \"640x480\" && styles.segmentActive,\n                pressed && styles.segmentPressed,\n              ]}\n              onPress={() => updateSetting(\"resolution\", \"640x480\")}\n            >\n              <Text\n                style={[\n                  styles.segmentText,\n                  settings.resolution === \"640x480\" && styles.segmentTextActive,\n                ]}\n              >\n                VGA (640×480)\n              </Text>\n            </Pressable>\n            <Pressable\n              style={({ pressed }) => [\n                styles.segment,\n                settings.resolution === \"320x240\" && styles.segmentActive,\n                pressed && styles.segmentPressed,\n              ]}\n              onPress={() => updateSetting(\"resolution\", \"320x240\")}\n            >\n              <Text\n                style={[\n                  styles.segmentText,\n                  settings.resolution === \"320x240\" && styles.segmentTextActive,\n                ]}\n              >\n                QVGA (320×240)\n              </Text>\n            </Pressable>\n          </View>\n        </View>\n\n        <View style={styles.settingRow}>\n          <View style={styles.labelContainer}>\n            <Text style={styles.label}>JPEG Compression</Text>\n            <Text style={styles.sublabel}>\n              {settings.compressionQuality === 0.1\n                ? \"High (Heavy artifacts)\"\n                : settings.compressionQuality === 0.3\n                ? \"Medium\"\n                : \"Low\"}\n            </Text>\n          </View>\n          <View style={styles.compressionButtons}>\n            {[\n              { value: 0.5, label: \"Low\" },\n              { value: 0.3, label: \"Med\" },\n              { value: 0.1, label: \"High\" },\n            ].map((option) => (\n              <Pressable\n                key={option.value}\n                style={({ pressed }) => [\n                  styles.compressionButton,\n                  settings.compressionQuality === option.value &&\n                    styles.compressionButtonActive,\n                  pressed && styles.segmentPressed,\n                ]}\n                onPress={() => updateSetting(\"compressionQuality\", option.value)}\n              >\n                <Text\n                  style={[\n                    styles.compressionButtonText,\n                    settings.compressionQuality === option.value &&\n                      styles.compressionButtonTextActive,\n                  ]}\n                >\n                  {option.label}\n                </Text>\n              </Pressable>\n            ))}\n          </View>\n        </View>\n      </View>\n\n      <View style={styles.section}>\n        <Text style={styles.sectionTitle}>Retro Effects</Text>\n\n        <View style={styles.settingRow}>\n          <View style={styles.labelContainer}>\n            <Text style={styles.label}>Timestamp Overlay</Text>\n            {settings.timestampEnabled && (\n              <Text\n                style={[\n                  styles.timestampPreview,\n                  {\n                    color:\n                      settings.timestampColor === \"yellow\"\n                        ? \"#FFD700\"\n                        : settings.timestampColor === \"red\"\n                        ? \"#FF4444\"\n                        : \"#FFFFFF\",\n                  },\n                ]}\n              >\n                {formatTimestamp(settings.timestampFormat)}\n              </Text>\n            )}\n          </View>\n          <Switch\n            value={settings.timestampEnabled}\n            onValueChange={(value) => updateSetting(\"timestampEnabled\", value)}\n            trackColor={{ false: \"#3A3A3C\", true: \"#52A57C\" }}\n            thumbColor=\"#FFFFFF\"\n          />\n        </View>\n\n        {settings.timestampEnabled && (\n          <>\n            <View style={styles.settingRow}>\n              <Text style={styles.label}>Format</Text>\n              <View style={styles.formatButtons}>\n                <Pressable\n                  style={({ pressed }) => [\n                    styles.formatButton,\n                    settings.timestampFormat === \"YYYY.MM.DD HH:MM\" &&\n                      styles.formatButtonActive,\n                    pressed && styles.segmentPressed,\n                  ]}\n                  onPress={() =>\n                    updateSetting(\"timestampFormat\", \"YYYY.MM.DD HH:MM\")\n                  }\n                >\n                  <Text\n                    style={[\n                      styles.formatButtonText,\n                      settings.timestampFormat === \"YYYY.MM.DD HH:MM\" &&\n                        styles.formatButtonTextActive,\n                    ]}\n                  >\n                    YYYY.MM.DD\n                  </Text>\n                </Pressable>\n                <Pressable\n                  style={({ pressed }) => [\n                    styles.formatButton,\n                    settings.timestampFormat === \"DD/MM/YYYY HH:MM\" &&\n                      styles.formatButtonActive,\n                    pressed && styles.segmentPressed,\n                  ]}\n                  onPress={() =>\n                    updateSetting(\"timestampFormat\", \"DD/MM/YYYY HH:MM\")\n                  }\n                >\n                  <Text\n                    style={[\n                      styles.formatButtonText,\n                      settings.timestampFormat === \"DD/MM/YYYY HH:MM\" &&\n                        styles.formatButtonTextActive,\n                    ]}\n                  >\n                    DD/MM/YYYY\n                  </Text>\n                </Pressable>\n              </View>\n            </View>\n\n            <View style={styles.settingRow}>\n              <Text style={styles.label}>Color</Text>\n              <View style={styles.colorButtons}>\n                {[\n                  { value: \"yellow\" as TimestampColor, color: \"#FFD700\" },\n                  { value: \"red\" as TimestampColor, color: \"#FF4444\" },\n                  { value: \"white\" as TimestampColor, color: \"#FFFFFF\" },\n                ].map((option) => (\n                  <Pressable\n                    key={option.value}\n                    style={({ pressed }) => [\n                      styles.colorButton,\n                      { backgroundColor: option.color },\n                      settings.timestampColor === option.value &&\n                        styles.colorButtonActive,\n                      pressed && styles.colorButtonPressed,\n                    ]}\n                    onPress={() => updateSetting(\"timestampColor\", option.value)}\n                  >\n                    {settings.timestampColor === option.value && (\n                      <Feather name=\"check\" size={16} color=\"#000000\" />\n                    )}\n                  </Pressable>\n                ))}\n              </View>\n            </View>\n          </>\n        )}\n\n        <View style={styles.settingRow}>\n          <Text style={styles.label}>Vignette Effect</Text>\n          <Switch\n            value={settings.vignetteEnabled}\n            onValueChange={(value) => updateSetting(\"vignetteEnabled\", value)}\n            trackColor={{ false: \"#3A3A3C\", true: \"#52A57C\" }}\n            thumbColor=\"#FFFFFF\"\n          />\n        </View>\n\n        <View style={styles.settingRow}>\n          <Text style={styles.label}>Noise & Grain</Text>\n          <Switch\n            value={settings.noiseEnabled}\n            onValueChange={(value) => updateSetting(\"noiseEnabled\", value)}\n            trackColor={{ false: \"#3A3A3C\", true: \"#52A57C\" }}\n            thumbColor=\"#FFFFFF\"\n          />\n        </View>\n      </View>\n\n      <View style={styles.section}>\n        <Text style={styles.sectionTitle}>Camera</Text>\n\n        <View style={styles.settingRow}>\n          <Text style={styles.label}>Shutter Sound</Text>\n          <Switch\n            value={settings.shutterSoundEnabled}\n            onValueChange={(value) => updateSetting(\"shutterSoundEnabled\", value)}\n            trackColor={{ false: \"#3A3A3C\", true: \"#52A57C\" }}\n            thumbColor=\"#FFFFFF\"\n          />\n        </View>\n\n        <View style={styles.settingRow}>\n          <Text style={styles.label}>Default Camera</Text>\n          <View style={styles.segmentedControl}>\n            <Pressable\n              style={({ pressed }) => [\n                styles.segment,\n                settings.defaultCamera === \"back\" && styles.segmentActive,\n                pressed && styles.segmentPressed,\n              ]}\n              onPress={() => updateSetting(\"defaultCamera\", \"back\")}\n            >\n              <Text\n                style={[\n                  styles.segmentText,\n                  settings.defaultCamera === \"back\" && styles.segmentTextActive,\n                ]}\n              >\n                Back\n              </Text>\n            </Pressable>\n            <Pressable\n              style={({ pressed }) => [\n                styles.segment,\n                settings.defaultCamera === \"front\" && styles.segmentActive,\n                pressed && styles.segmentPressed,\n              ]}\n              onPress={() => updateSetting(\"defaultCamera\", \"front\")}\n            >\n              <Text\n                style={[\n                  styles.segmentText,\n                  settings.defaultCamera === \"front\" && styles.segmentTextActive,\n                ]}\n              >\n                Front\n              </Text>\n            </Pressable>\n          </View>\n        </View>\n      </View>\n\n      <View style={styles.footer}>\n        <Text style={styles.footerText}>03cam v1.0.0</Text>\n        <Text style={styles.footerSubtext}>\n          Emulating the feel of year 2000 digital cameras\n        </Text>\n      </View>\n    </ScreenScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: Colors.dark.backgroundRoot,\n  },\n  section: {\n    padding: Spacing.md,\n    borderBottomWidth: 1,\n    borderBottomColor: Colors.dark.backgroundDefault,\n  },\n  sectionTitle: {\n    color: Colors.dark.text,\n    fontSize: 18,\n    fontWeight: \"600\",\n    marginBottom: Spacing.md,\n  },\n  settingRow: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    alignItems: \"center\",\n    paddingVertical: Spacing.md,\n    gap: Spacing.md,\n  },\n  labelContainer: {\n    flex: 1,\n  },\n  label: {\n    color: Colors.dark.text,\n    fontSize: 16,\n  },\n  sublabel: {\n    color: \"#B0C4BC\",\n    fontSize: 14,\n    marginTop: 4,\n  },\n  timestampPreview: {\n    fontSize: 12,\n    fontWeight: \"bold\",\n    marginTop: 4,\n  },\n  segmentedControl: {\n    flexDirection: \"row\",\n    backgroundColor: Colors.dark.backgroundDefault,\n    borderRadius: 8,\n    overflow: \"hidden\",\n  },\n  segment: {\n    paddingHorizontal: Spacing.md,\n    paddingVertical: Spacing.sm,\n  },\n  segmentActive: {\n    backgroundColor: Colors.dark.backgroundSecondary,\n  },\n  segmentPressed: {\n    opacity: 0.7,\n  },\n  segmentText: {\n    color: \"#B0C4BC\",\n    fontSize: 14,\n  },\n  segmentTextActive: {\n    color: Colors.dark.text,\n    fontWeight: \"600\",\n  },\n  compressionButtons: {\n    flexDirection: \"row\",\n    gap: Spacing.sm,\n  },\n  compressionButton: {\n    paddingHorizontal: Spacing.md,\n    paddingVertical: Spacing.sm,\n    borderRadius: 8,\n    backgroundColor: Colors.dark.backgroundDefault,\n  },\n  compressionButtonActive: {\n    backgroundColor: Colors.dark.backgroundSecondary,\n  },\n  compressionButtonText: {\n    color: \"#B0C4BC\",\n    fontSize: 14,\n  },\n  compressionButtonTextActive: {\n    color: Colors.dark.text,\n    fontWeight: \"600\",\n  },\n  formatButtons: {\n    flexDirection: \"row\",\n    gap: Spacing.sm,\n  },\n  formatButton: {\n    paddingHorizontal: Spacing.md,\n    paddingVertical: Spacing.sm,\n    borderRadius: 8,\n    backgroundColor: Colors.dark.backgroundDefault,\n  },\n  formatButtonActive: {\n    backgroundColor: Colors.dark.backgroundSecondary,\n  },\n  formatButtonText: {\n    color: \"#B0C4BC\",\n    fontSize: 14,\n  },\n  formatButtonTextActive: {\n    color: Colors.dark.text,\n    fontWeight: \"600\",\n  },\n  colorButtons: {\n    flexDirection: \"row\",\n    gap: Spacing.sm,\n  },\n  colorButton: {\n    width: 32,\n    height: 32,\n    borderRadius: 16,\n    justifyContent: \"center\",\n    alignItems: \"center\",\n  },\n  colorButtonActive: {\n    borderWidth: 2,\n    borderColor: \"#52A57C\",\n  },\n  colorButtonPressed: {\n    opacity: 0.7,\n  },\n  footer: {\n    padding: Spacing.xl,\n    alignItems: \"center\",\n  },\n  footerText: {\n    color: \"#B0C4BC\",\n    fontSize: 14,\n  },\n  footerSubtext: {\n    color: \"#6B7F77\",\n    fontSize: 12,\n    marginTop: 4,\n  },\n});\n","size_bytes":13858},"navigation/RootStackNavigator.tsx":{"content":"import { createNativeStackNavigator } from \"@react-navigation/native-stack\";\nimport CameraScreen from \"@/screens/CameraScreen\";\nimport SettingsScreen from \"@/screens/SettingsScreen\";\nimport GalleryScreen from \"@/screens/GalleryScreen\";\n\nexport type RootStackParamList = {\n  Camera: undefined;\n  Settings: undefined;\n  Gallery: { photos: string[] };\n};\n\nconst Stack = createNativeStackNavigator<RootStackParamList>();\n\nexport default function RootStackNavigator() {\n  return (\n    <Stack.Navigator\n      screenOptions={{\n        headerShown: false,\n      }}\n    >\n      <Stack.Screen name=\"Camera\" component={CameraScreen} />\n      <Stack.Screen\n        name=\"Settings\"\n        component={SettingsScreen}\n        options={{\n          presentation: \"modal\",\n          headerShown: true,\n          headerTitle: \"Settings\",\n          headerStyle: { backgroundColor: \"#0D1F17\" },\n          headerTintColor: \"#FFFFFF\",\n        }}\n      />\n      <Stack.Screen\n        name=\"Gallery\"\n        component={GalleryScreen}\n        options={{\n          presentation: \"fullScreenModal\",\n          headerShown: false,\n        }}\n      />\n    </Stack.Navigator>\n  );\n}\n","size_bytes":1152},"components/ErrorFallback.tsx":{"content":"import React, { useState } from \"react\";\nimport { reloadAppAsync } from \"expo\";\nimport {\n  StyleSheet,\n  View,\n  Pressable,\n  ScrollView,\n  Text,\n  Modal,\n} from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius, Fonts } from \"@/constants/theme\";\n\nexport type ErrorFallbackProps = {\n  error: Error;\n  resetError: () => void;\n};\n\nexport function ErrorFallback({ error, resetError }: ErrorFallbackProps) {\n  const { theme } = useTheme();\n  const [isModalVisible, setIsModalVisible] = useState(false);\n\n  const handleRestart = async () => {\n    try {\n      await reloadAppAsync();\n    } catch (restartError) {\n      console.error(\"Failed to restart app:\", restartError);\n      resetError();\n    }\n  };\n\n  const formatErrorDetails = (): string => {\n    let details = `Error: ${error.message}\\n\\n`;\n    if (error.stack) {\n      details += `Stack Trace:\\n${error.stack}`;\n    }\n    return details;\n  };\n\n  return (\n    <ThemedView style={styles.container}>\n      {__DEV__ ? (\n        <Pressable\n          onPress={() => setIsModalVisible(true)}\n          style={({ pressed }) => [\n            styles.topButton,\n            {\n              backgroundColor: theme.backgroundDefault,\n              opacity: pressed ? 0.8 : 1,\n            },\n          ]}\n        >\n          <Feather name=\"alert-circle\" size={20} color={theme.text} />\n        </Pressable>\n      ) : null}\n\n      <View style={styles.content}>\n        <ThemedText type=\"h1\" style={styles.title}>\n          Something went wrong\n        </ThemedText>\n\n        <ThemedText type=\"body\" style={styles.message}>\n          Please reload 03cam to continue capturing retro photos.\n        </ThemedText>\n\n        <Pressable\n          onPress={handleRestart}\n          style={({ pressed }) => [\n            styles.button,\n            {\n              backgroundColor: theme.link,\n              opacity: pressed ? 0.9 : 1,\n              transform: [{ scale: pressed ? 0.98 : 1 }],\n            },\n          ]}\n        >\n          <ThemedText\n            type=\"body\"\n            style={[styles.buttonText, { color: theme.buttonText }]}\n          >\n            Try Again\n          </ThemedText>\n        </Pressable>\n      </View>\n\n      {__DEV__ ? (\n        <Modal\n          visible={isModalVisible}\n          animationType=\"slide\"\n          transparent={true}\n          onRequestClose={() => setIsModalVisible(false)}\n        >\n          <View style={styles.modalOverlay}>\n            <ThemedView style={styles.modalContainer}>\n              <View style={styles.modalHeader}>\n                <ThemedText type=\"h2\" style={styles.modalTitle}>\n                  Error Details\n                </ThemedText>\n                <Pressable\n                  onPress={() => setIsModalVisible(false)}\n                  style={({ pressed }) => [\n                    styles.closeButton,\n                    { opacity: pressed ? 0.6 : 1 },\n                  ]}\n                >\n                  <Feather name=\"x\" size={24} color={theme.text} />\n                </Pressable>\n              </View>\n\n              <ScrollView\n                style={styles.modalScrollView}\n                contentContainerStyle={styles.modalScrollContent}\n                showsVerticalScrollIndicator\n              >\n                <View\n                  style={[\n                    styles.errorContainer,\n                    { backgroundColor: theme.backgroundDefault },\n                  ]}\n                >\n                  <Text\n                    style={[\n                      styles.errorText,\n                      {\n                        color: theme.text,\n                        fontFamily: Fonts?.mono || \"monospace\",\n                      },\n                    ]}\n                    selectable\n                  >\n                    {formatErrorDetails()}\n                  </Text>\n                </View>\n              </ScrollView>\n            </ThemedView>\n          </View>\n        </Modal>\n      ) : null}\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    width: \"100%\",\n    height: \"100%\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    padding: Spacing[\"2xl\"],\n  },\n  content: {\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    gap: Spacing.lg,\n    width: \"100%\",\n    maxWidth: 600,\n  },\n  title: {\n    textAlign: \"center\",\n    lineHeight: 40,\n  },\n  message: {\n    textAlign: \"center\",\n    opacity: 0.7,\n    lineHeight: 24,\n  },\n  topButton: {\n    position: \"absolute\",\n    top: Spacing[\"2xl\"] + Spacing.lg,\n    right: Spacing.lg,\n    width: 44,\n    height: 44,\n    borderRadius: BorderRadius.md,\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    zIndex: 10,\n  },\n  button: {\n    paddingVertical: Spacing.lg,\n    borderRadius: BorderRadius.md,\n    paddingHorizontal: Spacing[\"2xl\"],\n    minWidth: 200,\n    shadowColor: \"#000\",\n    shadowOffset: {\n      width: 0,\n      height: 2,\n    },\n    shadowOpacity: 0.1,\n    shadowRadius: 4,\n    elevation: 3,\n  },\n  buttonText: {\n    fontWeight: \"600\",\n    textAlign: \"center\",\n    fontSize: 16,\n  },\n  modalOverlay: {\n    flex: 1,\n    backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n    justifyContent: \"flex-end\",\n  },\n  modalContainer: {\n    width: \"100%\",\n    height: \"90%\",\n    borderTopLeftRadius: BorderRadius.lg,\n    borderTopRightRadius: BorderRadius.lg,\n  },\n  modalHeader: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.lg,\n    paddingTop: Spacing.lg,\n    paddingBottom: Spacing.md,\n    borderBottomWidth: 1,\n    borderBottomColor: \"rgba(128, 128, 128, 0.2)\",\n  },\n  modalTitle: {\n    fontWeight: \"600\",\n  },\n  closeButton: {\n    padding: Spacing.xs,\n  },\n  modalScrollView: {\n    flex: 1,\n  },\n  modalScrollContent: {\n    padding: Spacing.lg,\n  },\n  errorContainer: {\n    width: \"100%\",\n    borderRadius: BorderRadius.md,\n    overflow: \"hidden\",\n    padding: Spacing.lg,\n  },\n  errorText: {\n    fontSize: 12,\n    lineHeight: 18,\n    width: \"100%\",\n  },\n});\n","size_bytes":6215},"screens/CameraScreen.tsx":{"content":"import { useState, useRef, useEffect } from \"react\";\nimport {\n  View,\n  StyleSheet,\n  Pressable,\n  Text,\n  Alert,\n  Platform,\n} from \"react-native\";\nimport { CameraView, useCameraPermissions, FlashMode } from \"expo-camera\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useNavigation } from \"@react-navigation/native\";\nimport type { NativeStackNavigationProp } from \"@react-navigation/native-stack\";\nimport * as Haptics from \"expo-haptics\";\nimport { Spacing, Colors } from \"@/constants/theme\";\nimport type { RootStackParamList } from \"@/navigation/RootStackNavigator\";\nimport {\n  loadSettings,\n  type CameraSettings,\n  type FlashMode as FlashModeSetting,\n} from \"@/utils/settings\";\nimport { processPhoto, savePhotoToGallery, formatTimestamp } from \"@/utils/photoProcessing\";\n\ntype NavigationProp = NativeStackNavigationProp<RootStackParamList, \"Camera\">;\n\nexport default function CameraScreen() {\n  const [permission, requestPermission] = useCameraPermissions();\n  const [facing, setFacing] = useState<\"back\" | \"front\">(\"back\");\n  const [settings, setSettings] = useState<CameraSettings | null>(null);\n  const [isCapturing, setIsCapturing] = useState(false);\n  const cameraRef = useRef<CameraView>(null);\n  const insets = useSafeAreaInsets();\n  const navigation = useNavigation<NavigationProp>();\n\n  useEffect(() => {\n    loadSettings().then((loaded) => {\n      setSettings(loaded);\n      setFacing(loaded.defaultCamera);\n    });\n  }, []);\n\n  useEffect(() => {\n    const unsubscribe = navigation.addListener(\"focus\", () => {\n      loadSettings().then((loaded) => {\n        setSettings(loaded);\n      });\n    });\n    return unsubscribe;\n  }, [navigation]);\n\n  if (!permission) {\n    return <View style={styles.container} />;\n  }\n\n  if (!permission.granted) {\n    return (\n      <View style={[styles.container, styles.permissionContainer]}>\n        <Feather name=\"camera-off\" size={64} color={Colors.dark.text} />\n        <Text style={styles.permissionText}>\n          03cam needs camera access to capture retro photos\n        </Text>\n        <Pressable\n          style={({ pressed }) => [\n            styles.permissionButton,\n            pressed && styles.permissionButtonPressed,\n          ]}\n          onPress={requestPermission}\n        >\n          <Text style={styles.permissionButtonText}>Grant Permission</Text>\n        </Pressable>\n      </View>\n    );\n  }\n\n  if (!settings) {\n    return <View style={styles.container} />;\n  }\n\n  const handleCapture = async () => {\n    if (!cameraRef.current || isCapturing) return;\n\n    try {\n      setIsCapturing(true);\n\n      if (settings.shutterSoundEnabled && Platform.OS !== \"web\") {\n        Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);\n      }\n\n      const photo = await cameraRef.current.takePictureAsync({\n        quality: 1,\n        skipProcessing: true,\n      });\n\n      if (!photo) return;\n\n      const processedUri = await processPhoto(photo.uri, settings);\n      await savePhotoToGallery(processedUri);\n\n      Alert.alert(\"Photo saved\", \"Your retro photo has been saved to gallery\");\n    } catch (error) {\n      console.error(\"Failed to capture photo:\", error);\n      Alert.alert(\"Error\", \"Failed to capture photo. Please try again.\");\n    } finally {\n      setIsCapturing(false);\n    }\n  };\n\n  const toggleCamera = () => {\n    setFacing((current) => (current === \"back\" ? \"front\" : \"back\"));\n  };\n\n  const cycleFlash = () => {\n    setSettings((prev) => {\n      if (!prev) return prev;\n      const modes: FlashModeSetting[] = [\"auto\", \"on\", \"off\"];\n      const currentIndex = modes.indexOf(prev.flashMode);\n      const nextIndex = (currentIndex + 1) % modes.length;\n      return { ...prev, flashMode: modes[nextIndex] };\n    });\n  };\n\n  const getFlashIcon = (): keyof typeof Feather.glyphMap => {\n    switch (settings.flashMode) {\n      case \"on\":\n        return \"zap\";\n      case \"off\":\n        return \"zap-off\";\n      case \"auto\":\n        return \"zap\";\n    }\n  };\n\n  const getFlashColor = (): string => {\n    switch (settings.flashMode) {\n      case \"on\":\n        return \"#FFFFFF\";\n      case \"off\":\n        return \"#6B7F77\";\n      case \"auto\":\n        return \"#FFD700\";\n    }\n  };\n\n  const mapFlashMode = (mode: FlashModeSetting): FlashMode => {\n    switch (mode) {\n      case \"on\":\n        return \"on\";\n      case \"off\":\n        return \"off\";\n      case \"auto\":\n        return \"auto\";\n    }\n  };\n\n  return (\n    <View style={styles.container}>\n      <CameraView\n        ref={cameraRef}\n        style={styles.camera}\n        facing={facing}\n        flash={mapFlashMode(settings.flashMode)}\n      >\n        <View\n          style={[\n            styles.overlay,\n            { paddingTop: insets.top + Spacing.lg, paddingBottom: insets.bottom + Spacing.xl },\n          ]}\n        >\n          <View style={styles.topControls}>\n            <Pressable\n              style={({ pressed }) => [\n                styles.iconButton,\n                pressed && styles.iconButtonPressed,\n              ]}\n              onPress={toggleCamera}\n            >\n              <Feather name=\"rotate-cw\" size={24} color=\"#FFFFFF\" />\n            </Pressable>\n\n            <Text style={styles.resolutionIndicator}>\n              {settings.resolution === \"640x480\" ? \"VGA\" : \"QVGA\"}\n            </Text>\n\n            <View style={styles.topRightControls}>\n              <Pressable\n                style={({ pressed }) => [\n                  styles.iconButton,\n                  pressed && styles.iconButtonPressed,\n                ]}\n                onPress={cycleFlash}\n              >\n                <Feather name={getFlashIcon()} size={24} color={getFlashColor()} />\n              </Pressable>\n              <Pressable\n                style={({ pressed }) => [\n                  styles.iconButton,\n                  pressed && styles.iconButtonPressed,\n                ]}\n                onPress={() => navigation.navigate(\"Settings\")}\n              >\n                <Feather name=\"settings\" size={24} color=\"#FFFFFF\" />\n              </Pressable>\n            </View>\n          </View>\n\n          {settings.timestampEnabled && (\n            <View style={styles.timestampPreview}>\n              <Text\n                style={[\n                  styles.timestampText,\n                  {\n                    color:\n                      settings.timestampColor === \"yellow\"\n                        ? \"#FFD700\"\n                        : settings.timestampColor === \"red\"\n                        ? \"#FF4444\"\n                        : \"#FFFFFF\",\n                  },\n                ]}\n              >\n                {formatTimestamp(settings.timestampFormat)}\n              </Text>\n            </View>\n          )}\n\n          <View style={styles.bottomControls}>\n            <Pressable\n              style={({ pressed }) => [\n                styles.iconButton,\n                pressed && styles.iconButtonPressed,\n              ]}\n              onPress={() => navigation.navigate(\"Gallery\", { photos: [] })}\n            >\n              <Feather name=\"image\" size={24} color=\"#FFFFFF\" />\n            </Pressable>\n\n            <Pressable\n              style={({ pressed }) => [\n                styles.shutterButton,\n                pressed && styles.shutterButtonPressed,\n                isCapturing && styles.shutterButtonDisabled,\n              ]}\n              onPress={handleCapture}\n              disabled={isCapturing}\n            >\n              <Feather name=\"camera\" size={32} color=\"#FFFFFF\" />\n            </Pressable>\n\n            <View style={{ width: 48 }} />\n          </View>\n        </View>\n      </CameraView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: Colors.dark.backgroundRoot,\n  },\n  permissionContainer: {\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    padding: Spacing.xl,\n    gap: Spacing.lg,\n  },\n  permissionText: {\n    color: Colors.dark.text,\n    fontSize: 16,\n    textAlign: \"center\",\n    maxWidth: 300,\n  },\n  permissionButton: {\n    backgroundColor: Colors.dark.backgroundSecondary,\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.md,\n    borderRadius: 12,\n    marginTop: Spacing.md,\n  },\n  permissionButtonPressed: {\n    opacity: 0.7,\n  },\n  permissionButtonText: {\n    color: Colors.dark.text,\n    fontSize: 16,\n    fontWeight: \"600\",\n  },\n  camera: {\n    flex: 1,\n  },\n  overlay: {\n    flex: 1,\n    justifyContent: \"space-between\",\n  },\n  topControls: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.md,\n  },\n  topRightControls: {\n    flexDirection: \"row\",\n    gap: Spacing.sm,\n  },\n  iconButton: {\n    width: 48,\n    height: 48,\n    borderRadius: 24,\n    backgroundColor: \"rgba(0, 0, 0, 0.3)\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n  },\n  iconButtonPressed: {\n    opacity: 0.7,\n  },\n  resolutionIndicator: {\n    color: \"#FFFFFF\",\n    fontSize: 14,\n    fontWeight: \"600\",\n    backgroundColor: \"rgba(0, 0, 0, 0.3)\",\n    paddingHorizontal: Spacing.md,\n    paddingVertical: Spacing.sm,\n    borderRadius: 12,\n  },\n  timestampPreview: {\n    position: \"absolute\",\n    bottom: 120,\n    left: Spacing.md,\n    backgroundColor: \"rgba(0, 0, 0, 0.3)\",\n    paddingHorizontal: Spacing.sm,\n    paddingVertical: 4,\n    borderRadius: 4,\n  },\n  timestampText: {\n    fontFamily: Platform.select({ ios: \"Courier\", android: \"monospace\", default: \"monospace\" }),\n    fontSize: 12,\n    fontWeight: \"bold\",\n  },\n  bottomControls: {\n    flexDirection: \"row\",\n    justifyContent: \"space-around\",\n    alignItems: \"center\",\n    paddingBottom: Spacing.md,\n    paddingHorizontal: Spacing.xl,\n  },\n  shutterButton: {\n    width: 70,\n    height: 70,\n    borderRadius: 35,\n    backgroundColor: Colors.dark.backgroundSecondary,\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    shadowColor: \"#000\",\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.1,\n    shadowRadius: 2,\n    elevation: 2,\n  },\n  shutterButtonPressed: {\n    transform: [{ scale: 0.95 }],\n    opacity: 0.8,\n  },\n  shutterButtonDisabled: {\n    opacity: 0.5,\n  },\n});\n","size_bytes":10156},"App.tsx":{"content":"import React from \"react\";\nimport { StyleSheet } from \"react-native\";\nimport { NavigationContainer } from \"@react-navigation/native\";\nimport { GestureHandlerRootView } from \"react-native-gesture-handler\";\nimport { KeyboardProvider } from \"react-native-keyboard-controller\";\nimport { SafeAreaProvider } from \"react-native-safe-area-context\";\nimport { StatusBar } from \"expo-status-bar\";\n\nimport RootStackNavigator from \"@/navigation/RootStackNavigator\";\nimport { ErrorBoundary } from \"@/components/ErrorBoundary\";\n\nexport default function App() {\n  return (\n  <ErrorBoundary>\n    <SafeAreaProvider>\n        <GestureHandlerRootView style={styles.root}>\n          <KeyboardProvider>\n            <NavigationContainer>\n              <RootStackNavigator />\n            </NavigationContainer>\n            <StatusBar style=\"light\" />\n          </KeyboardProvider>\n        </GestureHandlerRootView>\n      </SafeAreaProvider>\n  </ErrorBoundary>\n  );\n}\n\nconst styles = StyleSheet.create({\n  root: {\n    flex: 1,\n  },\n});\n","size_bytes":1010},"eslint.config.js":{"content":"// https://docs.expo.dev/guides/using-eslint/\nconst { defineConfig } = require(\"eslint/config\");\nconst expoConfig = require(\"eslint-config-expo/flat\");\nconst eslintPluginPrettierRecommended = require(\"eslint-plugin-prettier/recommended\");\n\nmodule.exports = defineConfig([\n  expoConfig,\n  eslintPluginPrettierRecommended,\n  {\n    ignores: [\"dist/*\"],\n  },\n]);\n","size_bytes":359},"babel.config.js":{"content":"module.exports = function (api) {\n  api.cache(true);\n  return {\n    presets: [\"babel-preset-expo\"],\n    plugins: [\n      [\n        \"module-resolver\",\n        {\n          root: [\"./\"],\n          alias: {\n            \"@\": \"./\",\n          },\n          extensions: [\".ios.js\", \".android.js\", \".js\", \".ts\", \".tsx\", \".json\"],\n        },\n      ],\n      \"react-native-reanimated/plugin\",\n    ],\n  };\n};\n","size_bytes":395},"scripts/build.js":{"content":"const fs = require(\"fs\");\nconst path = require(\"path\");\nconst { spawn } = require(\"child_process\");\nconst { Readable } = require(\"stream\");\nconst { pipeline } = require(\"stream/promises\");\n\nlet metroProcess = null;\n\nfunction exitWithError(message) {\n  console.error(message);\n  if (metroProcess) {\n    metroProcess.kill();\n  }\n  process.exit(1);\n}\n\nfunction setupSignalHandlers() {\n  const cleanup = () => {\n    if (metroProcess) {\n      console.log(\"Cleaning up Metro process...\");\n      metroProcess.kill();\n    }\n    process.exit(0);\n  };\n\n  process.on(\"SIGINT\", cleanup);\n  process.on(\"SIGTERM\", cleanup);\n  process.on(\"SIGHUP\", cleanup);\n}\n\nfunction getDeploymentUrl() {\n  if (process.env.REPLIT_INTERNAL_APP_DOMAIN) {\n    const url = `https://${process.env.REPLIT_INTERNAL_APP_DOMAIN}`;\n    console.log(\"Using REPLIT_INTERNAL_APP_DOMAIN:\", url);\n    return url;\n  }\n\n  if (process.env.REPLIT_DEV_DOMAIN) {\n    const url = `https://${process.env.REPLIT_DEV_DOMAIN}`;\n    console.log(\"Using REPLIT_DEV_DOMAIN:\", url);\n    return url;\n  }\n\n  console.error(\n    \"ERROR: REPLIT_INTERNAL_APP_DOMAIN and REPLIT_DEV_DOMAIN not set\",\n  );\n  process.exit(1);\n}\n\nfunction prepareDirectories(timestamp) {\n  console.log(\"Preparing build directories...\");\n\n  if (fs.existsSync(\"static-build\")) {\n    fs.rmSync(\"static-build\", { recursive: true });\n  }\n\n  const dirs = [\n    path.join(\"static-build\", timestamp, \"_expo\", \"static\", \"js\", \"ios\"),\n    path.join(\"static-build\", timestamp, \"_expo\", \"static\", \"js\", \"android\"),\n    path.join(\"static-build\", \"ios\"),\n    path.join(\"static-build\", \"android\"),\n  ];\n\n  for (const dir of dirs) {\n    fs.mkdirSync(dir, { recursive: true });\n  }\n\n  console.log(\"Build:\", timestamp);\n}\n\nfunction clearMetroCache() {\n  console.log(\"Clearing Metro cache...\");\n\n  const cacheDirs = [\n    ...fs.globSync(\".metro-cache\"),\n    ...fs.globSync(\"node_modules/.cache/metro\"),\n  ];\n\n  for (const dir of cacheDirs) {\n    fs.rmSync(dir, { recursive: true, force: true });\n  }\n\n  console.log(\"Cache cleared\");\n}\n\nasync function checkMetroHealth() {\n  try {\n    const response = await fetch(\"http://localhost:8081/status\");\n    return response.ok;\n  } catch {\n    return false;\n  }\n}\n\nasync function startMetro() {\n  const isRunning = await checkMetroHealth();\n  if (isRunning) {\n    return;\n  }\n\n  console.log(\"Starting Metro...\");\n  metroProcess = spawn(\"npm\", [\"run\", \"dev\"], {\n    stdio: [\"ignore\", \"ignore\", \"ignore\"],\n    detached: false,\n  });\n\n  for (let i = 0; i < 30; i++) {\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n    const healthy = await checkMetroHealth();\n    if (healthy) {\n      console.log(\"Metro ready\");\n      return;\n    }\n  }\n\n  console.error(\"Metro timeout\");\n  process.exit(1);\n}\n\nasync function downloadFile(url, outputPath) {\n  try {\n    const response = await fetch(url);\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n\n    const file = fs.createWriteStream(outputPath);\n    await pipeline(Readable.fromWeb(response.body), file);\n\n    const fileSize = fs.statSync(outputPath).size;\n\n    if (fileSize === 0) {\n      fs.unlinkSync(outputPath);\n      throw new Error(\"Downloaded file is empty\");\n    }\n  } catch (error) {\n    if (fs.existsSync(outputPath)) {\n      fs.unlinkSync(outputPath);\n    }\n    throw error;\n  }\n}\n\nasync function downloadBundle(platform, timestamp) {\n  const url = new URL(\"http://localhost:8081/index.bundle\");\n  url.searchParams.set(\"platform\", platform);\n  url.searchParams.set(\"dev\", \"false\");\n  url.searchParams.set(\"hot\", \"false\");\n  url.searchParams.set(\"lazy\", \"false\");\n  url.searchParams.set(\"minify\", \"true\");\n\n  const output = path.join(\n    \"static-build\",\n    timestamp,\n    \"_expo\",\n    \"static\",\n    \"js\",\n    platform,\n    \"bundle.js\",\n  );\n\n  try {\n    await downloadFile(url.toString(), output);\n  } catch (error) {\n    exitWithError(`Failed to download ${platform} bundle: ${error.message}`);\n  }\n}\n\nasync function downloadManifest(platform) {\n  const response = await fetch(\"http://localhost:8081/manifest\", {\n    headers: { \"expo-platform\": platform },\n  });\n\n  if (!response.ok) {\n    throw new Error(`HTTP ${response.status}`);\n  }\n\n  return await response.json();\n}\n\nasync function downloadBundlesAndManifests(timestamp) {\n  console.log(\"Downloading bundles and manifests...\");\n\n  try {\n    const [, , iosManifest, androidManifest] = await Promise.all([\n      downloadBundle(\"ios\", timestamp),\n      downloadBundle(\"android\", timestamp),\n      downloadManifest(\"ios\"),\n      downloadManifest(\"android\"),\n    ]);\n    console.log(\"Downloaded\");\n    return { ios: iosManifest, android: androidManifest };\n  } catch (error) {\n    exitWithError(`Download failed: ${error.message}`);\n  }\n}\n\nfunction extractAssets(timestamp) {\n  const bundles = {\n    ios: fs.readFileSync(\n      path.join(\n        \"static-build\",\n        timestamp,\n        \"_expo\",\n        \"static\",\n        \"js\",\n        \"ios\",\n        \"bundle.js\",\n      ),\n      \"utf-8\",\n    ),\n    android: fs.readFileSync(\n      path.join(\n        \"static-build\",\n        timestamp,\n        \"_expo\",\n        \"static\",\n        \"js\",\n        \"android\",\n        \"bundle.js\",\n      ),\n      \"utf-8\",\n    ),\n  };\n\n  const assetsMap = new Map();\n  const assetPattern =\n    /httpServerLocation:\"([^\"]+)\"[^}]*hash:\"([^\"]+)\"[^}]*name:\"([^\"]+)\"[^}]*type:\"([^\"]+)\"/g;\n\n  const extractFromBundle = (bundle, platform) => {\n    for (const match of bundle.matchAll(assetPattern)) {\n      const originalPath = match[1];\n      const filename = match[3] + \".\" + match[4];\n\n      const tempUrl = new URL(`http://localhost:8081${originalPath}`);\n      const unstablePath = tempUrl.searchParams.get(\"unstable_path\");\n\n      if (!unstablePath) {\n        throw new Error(`Asset missing unstable_path: ${originalPath}`);\n      }\n\n      const decodedPath = decodeURIComponent(unstablePath).replace(/^\\.\\//, \"\");\n      const key = path.posix.join(decodedPath, filename);\n\n      if (!assetsMap.has(key)) {\n        const asset = {\n          url: path.posix.join(\"/\", decodedPath, filename),\n          originalPath: originalPath,\n          filename: filename,\n          relativePath: decodedPath,\n          hash: match[2],\n          platforms: new Set(),\n        };\n\n        assetsMap.set(key, asset);\n      }\n      assetsMap.get(key).platforms.add(platform);\n    }\n  };\n\n  extractFromBundle(bundles.ios, \"ios\");\n  extractFromBundle(bundles.android, \"android\");\n\n  return Array.from(assetsMap.values());\n}\n\nasync function downloadAssets(assets, timestamp) {\n  if (assets.length === 0) {\n    return 0;\n  }\n\n  console.log(\"Downloading assets...\");\n  let successCount = 0;\n  const failures = [];\n\n  const downloadPromises = assets.map(async (asset) => {\n    const platform = Array.from(asset.platforms)[0];\n\n    const tempUrl = new URL(`http://localhost:8081${asset.originalPath}`);\n    const unstablePath = tempUrl.searchParams.get(\"unstable_path\");\n\n    if (!unstablePath) {\n      throw new Error(`Asset missing unstable_path: ${asset.originalPath}`);\n    }\n\n    const decodedPath = decodeURIComponent(unstablePath).replace(/^\\./, \"\");\n    const metroUrl = new URL(\n      `http://localhost:8081${path.posix.join(\"/assets\", decodedPath, asset.filename)}`,\n    );\n    metroUrl.searchParams.set(\"platform\", platform);\n    metroUrl.searchParams.set(\"hash\", asset.hash);\n\n    const outputDir = path.join(\n      \"static-build\",\n      timestamp,\n      \"_expo\",\n      \"static\",\n      \"js\",\n      asset.relativePath,\n    );\n    fs.mkdirSync(outputDir, { recursive: true });\n    const output = path.join(outputDir, asset.filename);\n\n    try {\n      await downloadFile(metroUrl.toString(), output);\n      successCount++;\n    } catch (error) {\n      failures.push({\n        filename: asset.filename,\n        error: error.message,\n        url: metroUrl.toString(),\n      });\n    }\n  });\n\n  await Promise.all(downloadPromises);\n\n  if (failures.length > 0) {\n    const errorMsg =\n      `Failed to download ${failures.length} asset(s):\\n` +\n      failures\n        .map((f) => `  - ${f.filename}: ${f.error} (${f.url})`)\n        .join(\"\\n\");\n    exitWithError(errorMsg);\n  }\n\n  console.log(`Downloaded ${successCount} assets`);\n  return successCount;\n}\n\nfunction updateBundleUrls(timestamp, baseUrl) {\n  const updateForPlatform = (platform) => {\n    const bundlePath = path.join(\n      \"static-build\",\n      timestamp,\n      \"_expo\",\n      \"static\",\n      \"js\",\n      platform,\n      \"bundle.js\",\n    );\n    let bundle = fs.readFileSync(bundlePath, \"utf-8\");\n\n    bundle = bundle.replace(\n      /httpServerLocation:\"(\\/[^\"]+)\"/g,\n      (_match, capturedPath) => {\n        const tempUrl = new URL(`http://localhost:8081${capturedPath}`);\n        const unstablePath = tempUrl.searchParams.get(\"unstable_path\");\n\n        if (!unstablePath) {\n          throw new Error(\n            `Asset missing unstable_path in bundle: ${capturedPath}`,\n          );\n        }\n\n        const decodedPath = decodeURIComponent(unstablePath).replace(\n          /^\\.\\//,\n          \"\",\n        );\n        return `httpServerLocation:\"${baseUrl}/${timestamp}/_expo/static/js/${decodedPath}\"`;\n      },\n    );\n\n    fs.writeFileSync(bundlePath, bundle);\n  };\n\n  updateForPlatform(\"ios\");\n  updateForPlatform(\"android\");\n  console.log(\"Updated bundle URLs\");\n}\n\nfunction updateManifests(manifests, timestamp, baseUrl, assetsByHash) {\n  const updateForPlatform = (platform, manifest) => {\n    if (!manifest.launchAsset || !manifest.extra) {\n      exitWithError(`Malformed manifest for ${platform}`);\n    }\n\n    manifest.launchAsset.url = `${baseUrl}/${timestamp}/_expo/static/js/${platform}/bundle.js`;\n    manifest.launchAsset.key = `bundle-${timestamp}`;\n    manifest.createdAt = new Date(\n      Number(timestamp.split(\"-\")[0]),\n    ).toISOString();\n    manifest.extra.expoClient.hostUri =\n      baseUrl.replace(\"https://\", \"\") + \"/\" + platform;\n    manifest.extra.expoGo.debuggerHost =\n      baseUrl.replace(\"https://\", \"\") + \"/\" + platform;\n    manifest.extra.expoGo.packagerOpts.dev = false;\n\n    if (manifest.assets && manifest.assets.length > 0) {\n      manifest.assets.forEach((asset) => {\n        if (!asset.url) return;\n\n        const hash = asset.hash;\n        if (!hash) return;\n\n        const assetInfo = assetsByHash.get(hash);\n        if (!assetInfo) return;\n\n        asset.url = `${baseUrl}/${timestamp}/_expo/static/js/${assetInfo.relativePath}/${assetInfo.filename}`;\n      });\n    }\n\n    fs.writeFileSync(\n      path.join(\"static-build\", platform, \"manifest.json\"),\n      JSON.stringify(manifest, null, 2),\n    );\n  };\n\n  updateForPlatform(\"ios\", manifests.ios);\n  updateForPlatform(\"android\", manifests.android);\n  console.log(\"Manifests updated\");\n}\n\nfunction createLandingPage(baseUrl) {\n  const expsUrl = baseUrl.replace(\"https://\", \"\");\n  const template = fs.readFileSync(\n    path.join(\"scripts\", \"landing-page-template.html\"),\n    \"utf-8\",\n  );\n\n  const html = template\n    .replace(/BASE_URL_PLACEHOLDER/g, baseUrl)\n    .replace(/EXPS_URL_PLACEHOLDER/g, expsUrl);\n\n  fs.writeFileSync(path.join(\"static-build\", \"index.html\"), html);\n  console.log(\"Complete\");\n}\n\nasync function main() {\n  console.log(\"Building static Expo Go deployment...\");\n\n  setupSignalHandlers();\n\n  const baseUrl = getDeploymentUrl();\n  const timestamp = `${Date.now()}-${process.pid}`;\n\n  prepareDirectories(timestamp);\n  clearMetroCache();\n\n  await startMetro();\n  const manifests = await downloadBundlesAndManifests(timestamp);\n\n  console.log(\"Processing assets...\");\n  const assets = extractAssets(timestamp);\n  console.log(\"Found\", assets.length, \"unique asset(s)\");\n\n  const assetsByHash = new Map();\n  for (const asset of assets) {\n    assetsByHash.set(asset.hash, {\n      relativePath: asset.relativePath,\n      filename: asset.filename,\n    });\n  }\n\n  const assetCount = await downloadAssets(assets, timestamp);\n\n  if (assetCount > 0) {\n    updateBundleUrls(timestamp, baseUrl);\n  }\n\n  console.log(\"Updating manifests and creating landing page...\");\n  updateManifests(manifests, timestamp, baseUrl, assetsByHash);\n  createLandingPage(baseUrl);\n\n  console.log(\"Build complete! Deploy to:\", baseUrl);\n\n  if (metroProcess) {\n    metroProcess.kill();\n  }\n  process.exit(0);\n}\n\nmain().catch((error) => {\n  console.error(\"Build failed:\", error.message);\n  if (metroProcess) {\n    metroProcess.kill();\n  }\n  process.exit(1);\n});\n","size_bytes":12348},"utils/settings.ts":{"content":"import AsyncStorage from \"@react-native-async-storage/async-storage\";\n\nexport type Resolution = \"640x480\" | \"320x240\";\nexport type TimestampColor = \"yellow\" | \"red\" | \"white\";\nexport type FlashMode = \"auto\" | \"on\" | \"off\";\n\nexport interface CameraSettings {\n  resolution: Resolution;\n  compressionQuality: number;\n  effectIntensity: number;\n  timestampEnabled: boolean;\n  timestampFormat: \"YYYY.MM.DD HH:MM\" | \"DD/MM/YYYY HH:MM\";\n  timestampColor: TimestampColor;\n  vignetteEnabled: boolean;\n  noiseEnabled: boolean;\n  shutterSoundEnabled: boolean;\n  defaultCamera: \"back\" | \"front\";\n  flashMode: FlashMode;\n}\n\nconst DEFAULT_SETTINGS: CameraSettings = {\n  resolution: \"640x480\",\n  compressionQuality: 0.3,\n  effectIntensity: 1.0,\n  timestampEnabled: true,\n  timestampFormat: \"YYYY.MM.DD HH:MM\",\n  timestampColor: \"yellow\",\n  vignetteEnabled: true,\n  noiseEnabled: true,\n  shutterSoundEnabled: true,\n  defaultCamera: \"back\",\n  flashMode: \"auto\",\n};\n\nconst SETTINGS_KEY = \"@03cam_settings\";\n\nexport async function loadSettings(): Promise<CameraSettings> {\n  try {\n    const stored = await AsyncStorage.getItem(SETTINGS_KEY);\n    if (stored) {\n      return { ...DEFAULT_SETTINGS, ...JSON.parse(stored) };\n    }\n  } catch (error) {\n    console.error(\"Failed to load settings:\", error);\n  }\n  return DEFAULT_SETTINGS;\n}\n\nexport async function saveSettings(settings: CameraSettings): Promise<void> {\n  try {\n    await AsyncStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));\n  } catch (error) {\n    console.error(\"Failed to save settings:\", error);\n  }\n}\n","size_bytes":1554},"design_guidelines.md":{"content":"# 03cam Design Guidelines\n\n## Architecture Decisions\n\n### Authentication\n**No authentication required.** This is a single-user utility camera app with local storage only. All photos save directly to the device gallery.\n\n### Navigation\n**Stack-Only Navigation** - The app uses a simple linear navigation structure:\n- Camera screen (home/root)\n- Settings screen (modal overlay)\n- Gallery preview screen (full-screen modal)\n\nNo tab bar or drawer needed - keep it minimal like Y2K digital cameras.\n\n## Screen Specifications\n\n### 1. Camera Screen (Root)\n**Purpose:** Capture photos with Y2K retro effects\n\n**Layout:**\n- **Header:** None - full-screen camera preview for maximum immersion\n- **Main Content:** \n  - Full-screen camera preview (not scrollable)\n  - Floating shutter button centered at bottom\n  - Floating controls overlaid on preview\n- **Safe Area Insets:**\n  - Top: `insets.top + Spacing.lg`\n  - Bottom: `insets.bottom + Spacing.xl`\n\n**Components:**\n- Camera preview (full screen)\n- Large circular shutter button (70dp diameter) - center bottom with dark green fill and white camera icon\n- Settings icon button (top-right) - opens Settings screen\n- Camera flip icon button (top-left) - toggles front/back camera\n- Flash toggle button (top-right, next to settings) - cycles through auto/on/off states\n- Current resolution indicator (subtle text overlay, top-center) - shows \"VGA\" or \"QVGA\"\n- Timestamp preview (bottom-left corner) - shows how timestamp will appear if enabled\n\n**Visual Feedback:**\n- Shutter button: subtle scale animation (0.95x) on press + opacity 0.8\n- Camera flip: rotate animation when switching\n- Flash icon changes color: yellow (auto), white (on), gray (off)\n\n### 2. Settings Screen (Modal)\n**Purpose:** Configure camera resolution, effects, and timestamp options\n\n**Layout:**\n- **Header:** Material Design top app bar with \"Settings\" title, close button (left)\n- **Main Content:** Scrollable form/list\n- **Safe Area Insets:**\n  - Top: `Spacing.xl` (header handles safe area)\n  - Bottom: `insets.bottom + Spacing.xl`\n\n**Components (organized in sections):**\n\n**Image Settings:**\n- Resolution selector (segmented control or radio buttons):\n  - 640×480 (VGA) [default]\n  - 320×240 (QVGA)\n- JPEG compression slider (Low/Medium/High) - controls artifact intensity\n- Effect intensity slider (0-100%) - global effect strength multiplier\n\n**Retro Effects:**\n- Timestamp toggle switch with preview\n- Timestamp format selector (when enabled):\n  - YYYY.MM.DD HH:MM [default]\n  - DD/MM/YYYY HH:MM\n- Timestamp color picker: Yellow/Red/White\n- Vignette toggle switch\n- Noise/grain toggle switch\n\n**Camera:**\n- Shutter sound toggle switch\n- Default camera (front/back) selector\n\n**Visual Design:**\n- Dark green background (#0D1F17)\n- White text labels\n- Green accent switches (#2D5A4A)\n- Card-style sections with subtle dividers\n\n### 3. Gallery Preview Screen (Full-Screen Modal)\n**Purpose:** View recently captured retro photos within the app\n\n**Layout:**\n- **Header:** Minimal translucent header with back button (left), share button (right)\n- **Main Content:** \n  - Horizontal paginated image gallery (swipeable)\n  - Photo counter indicator (e.g., \"3/12\")\n- **Safe Area Insets:**\n  - Top: `headerHeight + Spacing.lg`\n  - Bottom: `insets.bottom + Spacing.lg`\n\n**Components:**\n- Full-screen image viewer with pinch-to-zoom\n- Delete button (bottom-right floating action button)\n- Image metadata display (bottom overlay, toggleable) - shows resolution, timestamp, file size\n- Previous/next navigation (swipe gestures)\n\n## Design System\n\n### Color Palette (Dark Green Theme)\n**Primary Colors:**\n- Background Dark: `#0D1F17`\n- Background Medium: `#1A2E26`\n- Surface: `#2D5A4A`\n- Primary Accent: `#3D7A5F`\n- Secondary Accent: `#52A57C`\n\n**Functional Colors:**\n- Text Primary: `#FFFFFF`\n- Text Secondary: `#B0C4BC`\n- Text Disabled: `#6B7F77`\n- Error: `#FF6B6B`\n- Success: `#4CAF50`\n\n**Retro Effect Colors:**\n- Timestamp Yellow: `#FFD700`\n- Timestamp Red: `#FF4444`\n- Timestamp White: `#FFFFFF`\n- Vignette Overlay: `#000000` at 40% opacity\n\n### Typography (Material Design 3)\n- **Headline:** Roboto Bold, 24sp\n- **Title:** Roboto Medium, 20sp\n- **Body:** Roboto Regular, 16sp\n- **Caption:** Roboto Regular, 12sp\n- **Button:** Roboto Medium, 14sp uppercase\n\n### Spacing Scale\n- xs: 4dp\n- sm: 8dp\n- md: 16dp\n- lg: 24dp\n- xl: 32dp\n- xxl: 48dp\n\n### Visual Design Principles\n\n**Camera Interface:**\n- Keep UI minimal - camera preview is the hero\n- Use semi-transparent overlays (black 30% opacity) behind floating buttons for legibility\n- Shutter button should be the most prominent element\n- All buttons use Feather icons from `@expo/vector-icons`\n\n**Material Design 3:**\n- Use elevated cards for settings sections\n- Apply subtle elevation (2dp) to floating action buttons only:\n  - shadowOffset: {width: 0, height: 2}\n  - shadowOpacity: 0.10\n  - shadowRadius: 2\n- Corner radius: 12dp for cards, 36dp for shutter button\n- Ripple effect on all touchable elements (native Android feedback)\n\n**Y2K Aesthetic Integration:**\n- Don't make the UI itself look retro - keep it modern and clean\n- The retro aesthetic applies ONLY to captured photos\n- Dark green theme evokes the LCD screens of old digital cameras\n- Timestamp overlay in photos should use pixelated monospace font (Courier or similar)\n\n### Assets Required\n\n**Icons (use Feather from @expo/vector-icons):**\n- camera (shutter button)\n- settings (settings access)\n- rotate-cw (flip camera)\n- zap / zap-off (flash toggle)\n- x (close modals)\n- share-2 (share photo)\n- trash-2 (delete photo)\n- image (gallery)\n\n**Custom Assets:**\n- App icon: Stylized \"03\" text in green with camera lens motif (512×512px)\n- Splash screen: Same \"03\" icon on dark green background\n\n**No other custom images needed** - the app's content is user-generated photos with retro processing applied.\n\n### Accessibility Requirements\n\n- All interactive elements minimum 48dp touch target\n- Contrast ratio 4.5:1 minimum for text on backgrounds\n- Screen reader labels for all icon buttons\n- Flash toggle states clearly distinguishable for colorblind users (use icons + text)\n- Camera permission request with clear explanation: \"03cam needs camera access to capture retro photos\"\n- Storage permission request: \"03cam needs storage access to save your photos\"","size_bytes":6285},"components/ScreenKeyboardAwareScrollView.tsx":{"content":"import { Platform, StyleSheet } from \"react-native\";\nimport {\n  KeyboardAwareScrollView,\n  KeyboardAwareScrollViewProps,\n} from \"react-native-keyboard-controller\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useScreenInsets } from \"@/hooks/useScreenInsets\";\nimport { Spacing } from \"@/constants/theme\";\nimport { ScreenScrollView } from \"./ScreenScrollView\";\n\nexport function ScreenKeyboardAwareScrollView({\n  children,\n  contentContainerStyle,\n  style,\n  keyboardShouldPersistTaps = \"handled\",\n  ...scrollViewProps\n}: KeyboardAwareScrollViewProps) {\n  const { theme } = useTheme();\n  const { paddingTop, paddingBottom, scrollInsetBottom } = useScreenInsets();\n\n  /**\n   * KeyboardAwareScrollView isn't compatible with web (it relies on native APIs), so the code falls back to ScreenScrollView on web to avoid runtime errors.\n   */\n  if (Platform.OS === \"web\") {\n    return (\n      <ScreenScrollView\n        style={style}\n        contentContainerStyle={contentContainerStyle}\n        keyboardShouldPersistTaps={keyboardShouldPersistTaps}\n        {...scrollViewProps}\n      >\n        {children}\n      </ScreenScrollView>\n    );\n  }\n\n  return (\n    <KeyboardAwareScrollView\n      style={[\n        styles.container,\n        { backgroundColor: theme.backgroundRoot },\n        style,\n      ]}\n      contentContainerStyle={[\n        {\n          paddingTop,\n          paddingBottom,\n        },\n        styles.contentContainer,\n        contentContainerStyle,\n      ]}\n      scrollIndicatorInsets={{ bottom: scrollInsetBottom }}\n      keyboardShouldPersistTaps={keyboardShouldPersistTaps}\n      {...scrollViewProps}\n    >\n      {children}\n    </KeyboardAwareScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  contentContainer: {\n    paddingHorizontal: Spacing.xl,\n  },\n});\n","size_bytes":1813},"components/Spacer.tsx":{"content":"import { View } from \"react-native\";\n\ntype Props = {\n  width?: number;\n  height?: number;\n};\n\nexport default function Spacer(props: Props) {\n  const width: number = props.width ?? 1;\n  const height: number = props.height ?? 1;\n\n  return (\n    <View\n      style={{\n        width,\n        height,\n      }}\n    />\n  );\n}\n","size_bytes":318},"components/ErrorBoundary.tsx":{"content":"import React, { Component, ComponentType, PropsWithChildren } from \"react\";\nimport { ErrorFallback, ErrorFallbackProps } from \"@/components/ErrorFallback\";\n\nexport type ErrorBoundaryProps = PropsWithChildren<{\n  FallbackComponent?: ComponentType<ErrorFallbackProps>;\n  onError?: (error: Error, stackTrace: string) => void;\n}>;\n\ntype ErrorBoundaryState = { error: Error | null };\n\n/**\n * This is a special case for for using the class components. Error boundaries must be class components because React only provides error boundary functionality through lifecycle methods (componentDidCatch and getDerivedStateFromError) which are not available in functional components.\n * https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary\n */\n\nexport class ErrorBoundary extends Component<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  state: ErrorBoundaryState = { error: null };\n\n  static defaultProps: {\n    FallbackComponent: ComponentType<ErrorFallbackProps>;\n  } = {\n    FallbackComponent: ErrorFallback,\n  };\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    return { error };\n  }\n\n  componentDidCatch(error: Error, info: { componentStack: string }): void {\n    if (typeof this.props.onError === \"function\") {\n      this.props.onError(error, info.componentStack);\n    }\n  }\n\n  resetError = (): void => {\n    this.setState({ error: null });\n  };\n\n  render() {\n    const { FallbackComponent } = this.props;\n\n    return this.state.error && FallbackComponent ? (\n      <FallbackComponent\n        error={this.state.error}\n        resetError={this.resetError}\n      />\n    ) : (\n      this.props.children\n    );\n  }\n}\n","size_bytes":1674},"replit.md":{"content":"# 03cam - Y2K Retro Camera App\n\n## Project Overview\n03cam is an Android camera app that emulates the aesthetic of year 2000 digital cameras with 0.3MP sensors. The app captures photos and applies retro effects to recreate the authentic look of early digital photography.\n\n## Architecture\n\n### Tech Stack\n- **Framework**: Expo SDK 54 / React Native\n- **Navigation**: React Navigation 7\n- **Storage**: AsyncStorage for settings persistence\n- **Image Processing**: expo-image-manipulator\n- **Camera**: expo-camera\n- **Media Library**: expo-media-library\n\n### Navigation Structure\nStack-only navigation with 3 screens:\n- Camera Screen (root) - Full-screen camera preview with capture controls\n- Settings Screen (modal) - Configuration options\n- Gallery Screen (modal) - View captured photos\n\n### Design System\n**Theme**: Dark green color palette inspired by LCD screens of old digital cameras\n- Background: `#0D1F17`\n- Surface: `#2D5A4A`\n- Primary Accent: `#3D7A5F`\n- Text: `#FFFFFF`\n\n**Typography**: System fonts with monospace for timestamps\n**Spacing**: 8dp base grid (4, 8, 16, 24, 32, 48dp)\n\n## Features Implemented\n\n### Core MVP Features\n1. **Camera Functionality**\n   - Full-screen camera preview\n   - Front/back camera toggle\n   - Flash control (auto/on/off)\n   - Photo capture with haptic feedback\n   - Save to device gallery\n\n2. **Y2K Photo Effects**\n   - Resolution downscaling (640×480 VGA, 320×240 QVGA)\n   - Heavy JPEG compression (adjustable 10-50%)\n   - Edge softness via multi-pass resize\n   - Effect intensity control (0-100%)\n\n3. **Settings**\n   - Resolution selector (VGA/QVGA)\n   - JPEG compression level (Low/Medium/High)\n   - Effect intensity slider\n   - Timestamp overlay toggle (with format and color options)\n   - Vignette effect toggle\n   - Noise/grain toggle\n   - Shutter sound toggle (haptic feedback)\n   - Default camera selection\n\n4. **Gallery**\n   - Grid view of captured photos\n   - Long-press to delete\n   - Permission handling\n\n### Technical Limitations\n\n**expo-image-manipulator constraints**:\nThe library only supports basic operations (resize, rotate, flip, crop, compress). Advanced pixel-level effects like color grading, RGB noise, vignetting, and timestamp overlays require either:\n- Native modules (not compatible with Expo Go)\n- Canvas/WebGL (unreliable in React Native)\n- Custom native image processing library\n\n**Current workarounds**:\n- Heavy JPEG compression creates authentic block artifacts\n- Multi-pass resize operations create edge softness and blur\n- Low resolution naturally creates pixelated look\n- Compression + resize combo approximates the Y2K aesthetic\n\n**Settings that are toggles only** (not fully applied to images):\n- `timestampEnabled` - Preview shown but not burned into saved photo\n- `vignetteEnabled` - Controls blur intensity\n- `noiseEnabled` - Controls blur intensity\n- Timestamp format/color - UI only, not applied to photos\n\n### File Structure\n```\n/screens\n  - CameraScreen.tsx       # Main camera interface\n  - SettingsScreen.tsx     # Configuration UI\n  - GalleryScreen.tsx      # Photo grid viewer\n\n/utils\n  - settings.ts            # AsyncStorage persistence\n  - photoProcessing.ts     # Image manipulation pipeline\n\n/navigation\n  - RootStackNavigator.tsx # Stack navigation setup\n\n/constants\n  - theme.ts               # Design tokens\n```\n\n## User Preferences\n- Dark mode only (matches retro camera LCD aesthetic)\n- Simple, minimal UI (no unnecessary decorations)\n- Maximum focus on camera preview\n- Settings persist across sessions\n\n## Recent Changes\n- Removed expo-av dependency (deprecated in SDK 54)\n- Implemented Y2K photo processing within expo-image-manipulator constraints\n- Added haptic feedback for shutter instead of audio\n- Created complete settings persistence system\n- Removed unused template files\n\n## Known Issues\n1. Expo Go on Android has limited media library access (requires development build for full functionality)\n2. CameraView doesn't support children (controls use absolute positioning)\n3. Timestamp overlay shown in preview but not burned into saved photos (limitation of expo-image-manipulator)\n4. Advanced color grading and noise effects not available without native image processing\n\n## Next Features (Future Development)\n- Custom save folder organization\n- Additional vintage camera presets\n- Horizontal banding effect for low-light\n- Photo sharing functionality\n- Customizable timestamp fonts from different camera brands\n- Consider native image processing module for true pixel-level effects\n","size_bytes":4498},"components/ScreenFlatList.tsx":{"content":"import React from \"react\";\nimport { FlatList, FlatListProps, StyleSheet } from \"react-native\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useScreenInsets } from \"@/hooks/useScreenInsets\";\nimport { Spacing } from \"@/constants/theme\";\n\nexport function ScreenFlatList<T>({\n  contentContainerStyle,\n  style,\n  ...flatListProps\n}: FlatListProps<T>) {\n  const { theme } = useTheme();\n  const { paddingTop, paddingBottom, scrollInsetBottom } = useScreenInsets();\n\n  return (\n    <FlatList\n      style={[\n        styles.container,\n        { backgroundColor: theme.backgroundRoot },\n        style,\n      ]}\n      contentContainerStyle={[\n        {\n          paddingTop,\n          paddingBottom,\n        },\n        styles.contentContainer,\n        contentContainerStyle,\n      ]}\n      scrollIndicatorInsets={{ bottom: scrollInsetBottom }}\n      {...flatListProps}\n    />\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  contentContainer: {\n    paddingHorizontal: Spacing.xl,\n  },\n});\n","size_bytes":1016},"components/ScreenScrollView.tsx":{"content":"import { ScrollView, ScrollViewProps, StyleSheet } from \"react-native\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useScreenInsets } from \"@/hooks/useScreenInsets\";\nimport { Spacing } from \"@/constants/theme\";\n\nexport function ScreenScrollView({\n  children,\n  contentContainerStyle,\n  style,\n  ...scrollViewProps\n}: ScrollViewProps) {\n  const { theme } = useTheme();\n  const { paddingTop, paddingBottom, scrollInsetBottom } = useScreenInsets();\n\n  return (\n    <ScrollView\n      style={[\n        styles.container,\n        { backgroundColor: theme.backgroundRoot },\n        style,\n      ]}\n      contentContainerStyle={[\n        {\n          paddingTop,\n          paddingBottom,\n        },\n        styles.contentContainer,\n        contentContainerStyle,\n      ]}\n      scrollIndicatorInsets={{ bottom: scrollInsetBottom }}\n      {...scrollViewProps}\n    >\n      {children}\n    </ScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  contentContainer: {\n    paddingHorizontal: Spacing.xl,\n  },\n});\n","size_bytes":1043},"screens/GalleryScreen.tsx":{"content":"import { useState, useEffect } from \"react\";\nimport {\n  View,\n  StyleSheet,\n  Text,\n  FlatList,\n  Image,\n  Pressable,\n  Alert,\n  Dimensions,\n} from \"react-native\";\nimport * as MediaLibrary from \"expo-media-library\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useNavigation } from \"@react-navigation/native\";\nimport { Colors, Spacing } from \"@/constants/theme\";\n\nconst { width } = Dimensions.get(\"window\");\nconst COLUMN_COUNT = 3;\nconst SPACING = 2;\nconst ITEM_SIZE = (width - SPACING * (COLUMN_COUNT + 1)) / COLUMN_COUNT;\n\nexport default function GalleryScreen() {\n  const [permission, requestPermission] = MediaLibrary.usePermissions();\n  const [photos, setPhotos] = useState<MediaLibrary.Asset[]>([]);\n  const [loading, setLoading] = useState(true);\n  const insets = useSafeAreaInsets();\n  const navigation = useNavigation();\n\n  useEffect(() => {\n    loadPhotos();\n  }, []);\n\n  const loadPhotos = async () => {\n    try {\n      if (!permission?.granted) {\n        const result = await requestPermission();\n        if (!result.granted) {\n          setLoading(false);\n          return;\n        }\n      }\n\n      const album = await MediaLibrary.getAlbumAsync(\"Camera\");\n      if (album) {\n        const { assets } = await MediaLibrary.getAssetsAsync({\n          album: album,\n          mediaType: \"photo\",\n          sortBy: MediaLibrary.SortBy.creationTime,\n          first: 100,\n        });\n        setPhotos(assets);\n      }\n    } catch (error) {\n      console.error(\"Failed to load photos:\", error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleDeletePhoto = async (asset: MediaLibrary.Asset) => {\n    Alert.alert(\"Delete Photo\", \"Are you sure you want to delete this photo?\", [\n      { text: \"Cancel\", style: \"cancel\" },\n      {\n        text: \"Delete\",\n        style: \"destructive\",\n        onPress: async () => {\n          try {\n            await MediaLibrary.deleteAssetsAsync([asset]);\n            setPhotos((prev) => prev.filter((p) => p.id !== asset.id));\n          } catch (error) {\n            console.error(\"Failed to delete photo:\", error);\n            Alert.alert(\"Error\", \"Failed to delete photo\");\n          }\n        },\n      },\n    ]);\n  };\n\n  if (!permission?.granted) {\n    return (\n      <View style={[styles.container, styles.centerContent]}>\n        <View\n          style={{\n            paddingTop: insets.top + Spacing.lg,\n            paddingBottom: insets.bottom + Spacing.xl,\n            alignItems: \"center\",\n            gap: Spacing.lg,\n          }}\n        >\n          <Feather name=\"image\" size={64} color={Colors.dark.text} />\n          <Text style={styles.emptyText}>\n            Gallery access required to view photos\n          </Text>\n          <Pressable\n            style={({ pressed }) => [\n              styles.permissionButton,\n              pressed && styles.permissionButtonPressed,\n            ]}\n            onPress={requestPermission}\n          >\n            <Text style={styles.permissionButtonText}>Grant Permission</Text>\n          </Pressable>\n        </View>\n        <Pressable\n          style={[styles.closeButton, { top: insets.top + Spacing.sm }]}\n          onPress={() => navigation.goBack()}\n        >\n          <Feather name=\"x\" size={24} color=\"#FFFFFF\" />\n        </Pressable>\n      </View>\n    );\n  }\n\n  if (loading) {\n    return (\n      <View style={[styles.container, styles.centerContent]}>\n        <Text style={styles.emptyText}>Loading photos...</Text>\n      </View>\n    );\n  }\n\n  if (photos.length === 0) {\n    return (\n      <View style={[styles.container, styles.centerContent]}>\n        <View\n          style={{\n            paddingTop: insets.top + Spacing.lg,\n            paddingBottom: insets.bottom + Spacing.xl,\n            alignItems: \"center\",\n            gap: Spacing.lg,\n          }}\n        >\n          <Feather name=\"camera\" size={64} color={Colors.dark.text} />\n          <Text style={styles.emptyText}>No photos yet</Text>\n          <Text style={styles.emptySubtext}>\n            Capture your first retro photo!\n          </Text>\n        </View>\n        <Pressable\n          style={[styles.closeButton, { top: insets.top + Spacing.sm }]}\n          onPress={() => navigation.goBack()}\n        >\n          <Feather name=\"x\" size={24} color=\"#FFFFFF\" />\n        </Pressable>\n      </View>\n    );\n  }\n\n  return (\n    <View style={styles.container}>\n      <View\n        style={[styles.header, { paddingTop: insets.top + Spacing.sm }]}\n      >\n        <Pressable\n          style={({ pressed }) => [\n            styles.headerButton,\n            pressed && styles.headerButtonPressed,\n          ]}\n          onPress={() => navigation.goBack()}\n        >\n          <Feather name=\"x\" size={24} color=\"#FFFFFF\" />\n        </Pressable>\n        <Text style={styles.headerTitle}>Gallery ({photos.length})</Text>\n        <View style={{ width: 48 }} />\n      </View>\n\n      <FlatList\n        data={photos}\n        numColumns={COLUMN_COUNT}\n        contentContainerStyle={{\n          padding: SPACING,\n          paddingBottom: insets.bottom + Spacing.xl,\n        }}\n        columnWrapperStyle={{ gap: SPACING }}\n        keyExtractor={(item) => item.id}\n        renderItem={({ item }) => (\n          <Pressable\n            style={styles.photoContainer}\n            onLongPress={() => handleDeletePhoto(item)}\n          >\n            <Image source={{ uri: item.uri }} style={styles.photo} />\n          </Pressable>\n        )}\n        ItemSeparatorComponent={() => <View style={{ height: SPACING }} />}\n      />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: Colors.dark.backgroundRoot,\n  },\n  centerContent: {\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    padding: Spacing.xl,\n  },\n  header: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.md,\n    paddingBottom: Spacing.md,\n    backgroundColor: Colors.dark.backgroundRoot,\n  },\n  headerButton: {\n    width: 48,\n    height: 48,\n    borderRadius: 24,\n    backgroundColor: \"rgba(255, 255, 255, 0.1)\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n  },\n  headerButtonPressed: {\n    opacity: 0.7,\n  },\n  headerTitle: {\n    color: Colors.dark.text,\n    fontSize: 18,\n    fontWeight: \"600\",\n  },\n  closeButton: {\n    position: \"absolute\",\n    left: Spacing.md,\n    width: 48,\n    height: 48,\n    borderRadius: 24,\n    backgroundColor: \"rgba(0, 0, 0, 0.3)\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n  },\n  emptyText: {\n    color: Colors.dark.text,\n    fontSize: 18,\n    fontWeight: \"600\",\n    textAlign: \"center\",\n  },\n  emptySubtext: {\n    color: \"#B0C4BC\",\n    fontSize: 14,\n    textAlign: \"center\",\n  },\n  permissionButton: {\n    backgroundColor: Colors.dark.backgroundSecondary,\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.md,\n    borderRadius: 12,\n    marginTop: Spacing.md,\n  },\n  permissionButtonPressed: {\n    opacity: 0.7,\n  },\n  permissionButtonText: {\n    color: Colors.dark.text,\n    fontSize: 16,\n    fontWeight: \"600\",\n  },\n  photoContainer: {\n    width: ITEM_SIZE,\n    height: ITEM_SIZE,\n  },\n  photo: {\n    width: \"100%\",\n    height: \"100%\",\n    backgroundColor: Colors.dark.backgroundDefault,\n  },\n});\n","size_bytes":7312},"hooks/useTheme.ts":{"content":"import { Colors } from \"@/constants/theme\";\nimport { useColorScheme } from \"@/hooks/useColorScheme\";\n\nexport function useTheme() {\n  const colorScheme = useColorScheme();\n  const isDark = colorScheme === \"dark\";\n  const theme = Colors[colorScheme ?? \"light\"];\n\n  return {\n    theme,\n    isDark,\n  };\n}\n","size_bytes":302},"navigation/screenOptions.ts":{"content":"import { Platform } from \"react-native\";\nimport { NativeStackNavigationOptions } from \"@react-navigation/native-stack\";\nimport { isLiquidGlassAvailable } from \"expo-glass-effect\";\n\ninterface ScreenOptionsParams {\n  theme: {\n    backgroundRoot: string;\n    text: string;\n  };\n  isDark: boolean;\n  transparent?: boolean;\n}\n\nexport const getCommonScreenOptions = ({\n  theme,\n  isDark,\n  transparent = true,\n}: ScreenOptionsParams): NativeStackNavigationOptions => ({\n  headerTitleAlign: \"center\",\n  headerTransparent: transparent,\n  headerBlurEffect: isDark ? \"dark\" : \"light\",\n  headerTintColor: theme.text,\n  headerStyle: {\n    backgroundColor: Platform.select({\n      ios: undefined,\n      android: theme.backgroundRoot,\n      web: theme.backgroundRoot,\n    }),\n  },\n  gestureEnabled: true,\n  gestureDirection: \"horizontal\",\n  fullScreenGestureEnabled: isLiquidGlassAvailable() ? false : true,\n  contentStyle: {\n    backgroundColor: theme.backgroundRoot,\n  },\n});\n","size_bytes":964},"index.js":{"content":"import { registerRootComponent } from \"expo\";\n\nimport App from \"@/App\";\n\nregisterRootComponent(App);\n","size_bytes":101},"hooks/useColorScheme.ts":{"content":"export { useColorScheme } from \"react-native\";\n","size_bytes":47},"utils/photoProcessing.ts":{"content":"import { manipulateAsync, SaveFormat, FlipType } from \"expo-image-manipulator\";\nimport * as MediaLibrary from \"expo-media-library\";\nimport type { CameraSettings, Resolution } from \"./settings\";\n\nexport function getResolutionDimensions(resolution: Resolution): {\n  width: number;\n  height: number;\n} {\n  switch (resolution) {\n    case \"640x480\":\n      return { width: 640, height: 480 };\n    case \"320x240\":\n      return { width: 320, height: 240 };\n  }\n}\n\nexport function formatTimestamp(\n  format: \"YYYY.MM.DD HH:MM\" | \"DD/MM/YYYY HH:MM\"\n): string {\n  const now = new Date();\n  const year = now.getFullYear();\n  const month = String(now.getMonth() + 1).padStart(2, \"0\");\n  const day = String(now.getDate()).padStart(2, \"0\");\n  const hours = String(now.getHours()).padStart(2, \"0\");\n  const minutes = String(now.getMinutes()).padStart(2, \"0\");\n\n  if (format === \"YYYY.MM.DD HH:MM\") {\n    return `${year}.${month}.${day}  ${hours}:${minutes}`;\n  } else {\n    return `${day}/${month}/${year} ${hours}:${minutes}`;\n  }\n}\n\nexport async function processPhoto(\n  photoUri: string,\n  settings: CameraSettings\n): Promise<string> {\n  try {\n    const { width, height } = getResolutionDimensions(settings.resolution);\n    const intensity = settings.effectIntensity;\n\n    const manipulations: any[] = [\n      { resize: { width, height } },\n    ];\n\n    if (settings.vignetteEnabled || settings.noiseEnabled) {\n      const effectScale = 0.75 + (0.20 * (1 - intensity));\n      const effectWidth = Math.floor(width * effectScale);\n      const effectHeight = Math.floor(height * effectScale);\n      manipulations.push({ resize: { width: effectWidth, height: effectHeight } });\n      manipulations.push({ resize: { width, height } });\n    }\n\n    const compressionLevel = settings.compressionQuality * (0.5 + 0.5 * (1 - intensity));\n\n    let result = await manipulateAsync(photoUri, manipulations, {\n      compress: Math.max(0.05, Math.min(0.6, compressionLevel)),\n      format: SaveFormat.JPEG,\n    });\n\n    return result.uri;\n  } catch (error) {\n    console.error(\"Failed to process photo:\", error);\n    throw error;\n  }\n}\n\nexport async function savePhotoToGallery(uri: string): Promise<void> {\n  try {\n    const { status } = await MediaLibrary.requestPermissionsAsync();\n    if (status !== \"granted\") {\n      throw new Error(\"Permission to access media library denied\");\n    }\n\n    await MediaLibrary.createAssetAsync(uri);\n  } catch (error) {\n    console.error(\"Failed to save photo to gallery:\", error);\n    throw error;\n  }\n}\n","size_bytes":2513},"components/Card.tsx":{"content":"import React from \"react\";\nimport { StyleSheet, Pressable } from \"react-native\";\nimport Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n  WithSpringConfig,\n} from \"react-native-reanimated\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius } from \"@/constants/theme\";\n\ninterface CardProps {\n  elevation: number;\n  onPress?: () => void;\n}\n\nconst springConfig: WithSpringConfig = {\n  damping: 15,\n  mass: 0.3,\n  stiffness: 150,\n  overshootClamping: true,\n  energyThreshold: 0.001,\n};\n\nconst getBackgroundColorForElevation = (\n  elevation: number,\n  theme: any,\n): string => {\n  switch (elevation) {\n    case 1:\n      return theme.backgroundDefault;\n    case 2:\n      return theme.backgroundSecondary;\n    case 3:\n      return theme.backgroundTertiary;\n    default:\n      return theme.backgroundRoot;\n  }\n};\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\nexport function Card({ elevation, onPress }: CardProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const cardBackgroundColor = getBackgroundColorForElevation(elevation, theme);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const handlePressIn = () => {\n    scale.value = withSpring(0.98, springConfig);\n  };\n\n  const handlePressOut = () => {\n    scale.value = withSpring(1, springConfig);\n  };\n\n  return (\n    <AnimatedPressable\n      onPress={onPress}\n      onPressIn={handlePressIn}\n      onPressOut={handlePressOut}\n      style={[\n        styles.card,\n        {\n          backgroundColor: cardBackgroundColor,\n        },\n        animatedStyle,\n      ]}\n    >\n      <ThemedText type=\"h4\" style={styles.cardTitle}>\n        Card - Elevation {elevation}\n      </ThemedText>\n      <ThemedText type=\"small\" style={styles.cardDescription}>\n        This card has an elevation of {elevation}\n      </ThemedText>\n    </AnimatedPressable>\n  );\n}\n\nconst styles = StyleSheet.create({\n  card: {\n    padding: Spacing.xl,\n    borderRadius: BorderRadius[\"2xl\"],\n  },\n  cardTitle: {\n    marginBottom: Spacing.sm,\n  },\n  cardDescription: {\n    opacity: 0.7,\n  },\n});\n","size_bytes":2211},"components/ThemedText.tsx":{"content":"import { Text, type TextProps } from \"react-native\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Typography } from \"@/constants/theme\";\n\nexport type ThemedTextProps = TextProps & {\n  lightColor?: string;\n  darkColor?: string;\n  type?: \"h1\" | \"h2\" | \"h3\" | \"h4\" | \"body\" | \"small\" | \"link\";\n};\n\nexport function ThemedText({\n  style,\n  lightColor,\n  darkColor,\n  type = \"body\",\n  ...rest\n}: ThemedTextProps) {\n  const { theme, isDark } = useTheme();\n\n  const getColor = () => {\n    if (isDark && darkColor) {\n      return darkColor;\n    }\n\n    if (!isDark && lightColor) {\n      return lightColor;\n    }\n\n    if (type === \"link\") {\n      return theme.link;\n    }\n\n    return theme.text;\n  };\n\n  const getTypeStyle = () => {\n    switch (type) {\n      case \"h1\":\n        return Typography.h1;\n      case \"h2\":\n        return Typography.h2;\n      case \"h3\":\n        return Typography.h3;\n      case \"h4\":\n        return Typography.h4;\n      case \"body\":\n        return Typography.body;\n      case \"small\":\n        return Typography.small;\n      case \"link\":\n        return Typography.link;\n      default:\n        return Typography.body;\n    }\n  };\n\n  return (\n    <Text style={[{ color: getColor() }, getTypeStyle(), style]} {...rest} />\n  );\n}\n","size_bytes":1251},"components/Button.tsx":{"content":"import React, { ReactNode } from \"react\";\nimport { StyleSheet, Pressable, ViewStyle, StyleProp } from \"react-native\";\nimport Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n  WithSpringConfig,\n} from \"react-native-reanimated\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { BorderRadius, Spacing } from \"@/constants/theme\";\n\ninterface ButtonProps {\n  onPress?: () => void;\n  children: ReactNode;\n  style?: StyleProp<ViewStyle>;\n  disabled?: boolean;\n}\n\nconst springConfig: WithSpringConfig = {\n  damping: 15,\n  mass: 0.3,\n  stiffness: 150,\n  overshootClamping: true,\n  energyThreshold: 0.001,\n};\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\nexport function Button({\n  onPress,\n  children,\n  style,\n  disabled = false,\n}: ButtonProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const handlePressIn = () => {\n    if (!disabled) {\n      scale.value = withSpring(0.98, springConfig);\n    }\n  };\n\n  const handlePressOut = () => {\n    if (!disabled) {\n      scale.value = withSpring(1, springConfig);\n    }\n  };\n\n  return (\n    <AnimatedPressable\n      onPress={disabled ? undefined : onPress}\n      onPressIn={handlePressIn}\n      onPressOut={handlePressOut}\n      disabled={disabled}\n      style={[\n        styles.button,\n        {\n          backgroundColor: theme.link,\n          opacity: disabled ? 0.5 : 1,\n        },\n        style,\n        animatedStyle,\n      ]}\n    >\n      <ThemedText\n        type=\"body\"\n        style={[styles.buttonText, { color: theme.buttonText }]}\n      >\n        {children}\n      </ThemedText>\n    </AnimatedPressable>\n  );\n}\n\nconst styles = StyleSheet.create({\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.full,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  buttonText: {\n    fontWeight: \"600\",\n  },\n});\n","size_bytes":2014},"hooks/useScreenInsets.ts":{"content":"import { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useHeaderHeight } from \"@react-navigation/elements\";\n\nimport { Spacing } from \"@/constants/theme\";\n\nexport function useScreenInsets() {\n  const insets = useSafeAreaInsets();\n  const headerHeight = useHeaderHeight();\n\n  return {\n    paddingTop: headerHeight + Spacing.xl,\n    paddingBottom: insets.bottom + Spacing.xl,\n    scrollInsetBottom: insets.bottom + 16,\n  };\n}\n","size_bytes":445},"constants/theme.ts":{"content":"import { Platform } from \"react-native\";\n\nconst tintColorLight = \"#3D7A5F\";\nconst tintColorDark = \"#52A57C\";\n\nexport const Colors = {\n  light: {\n    text: \"#FFFFFF\",\n    buttonText: \"#FFFFFF\",\n    tabIconDefault: \"#6B7F77\",\n    tabIconSelected: tintColorLight,\n    link: \"#3D7A5F\",\n    backgroundRoot: \"#0D1F17\",\n    backgroundDefault: \"#1A2E26\",\n    backgroundSecondary: \"#2D5A4A\",\n    backgroundTertiary: \"#3D7A5F\",\n  },\n  dark: {\n    text: \"#FFFFFF\",\n    buttonText: \"#FFFFFF\",\n    tabIconDefault: \"#6B7F77\",\n    tabIconSelected: tintColorDark,\n    link: \"#52A57C\",\n    backgroundRoot: \"#0D1F17\",\n    backgroundDefault: \"#1A2E26\",\n    backgroundSecondary: \"#2D5A4A\",\n    backgroundTertiary: \"#3D7A5F\",\n  },\n};\n\nexport const Spacing = {\n  xs: 4,\n  sm: 8,\n  md: 16,\n  lg: 24,\n  xl: 32,\n  \"2xl\": 48,\n  \"3xl\": 64,\n  \"4xl\": 80,\n  \"5xl\": 96,\n  inputHeight: 48,\n  buttonHeight: 52,\n};\n\nexport const BorderRadius = {\n  xs: 8,\n  sm: 12,\n  md: 18,\n  lg: 24,\n  xl: 30,\n  \"2xl\": 40,\n  \"3xl\": 50,\n  full: 9999,\n};\n\nexport const Typography = {\n  h1: {\n    fontSize: 32,\n    lineHeight: 40,\n    fontWeight: \"700\" as const,\n  },\n  h2: {\n    fontSize: 28,\n    lineHeight: 36,\n    fontWeight: \"700\" as const,\n  },\n  h3: {\n    fontSize: 24,\n    lineHeight: 32,\n    fontWeight: \"600\" as const,\n  },\n  h4: {\n    fontSize: 20,\n    lineHeight: 28,\n    fontWeight: \"600\" as const,\n  },\n  body: {\n    fontSize: 16,\n    lineHeight: 24,\n    fontWeight: \"400\" as const,\n  },\n  small: {\n    fontSize: 14,\n    lineHeight: 20,\n    fontWeight: \"400\" as const,\n  },\n  link: {\n    fontSize: 16,\n    lineHeight: 24,\n    fontWeight: \"400\" as const,\n  },\n};\n\nexport const Fonts = Platform.select({\n  ios: {\n    /** iOS `UIFontDescriptorSystemDesignDefault` */\n    sans: \"system-ui\",\n    /** iOS `UIFontDescriptorSystemDesignSerif` */\n    serif: \"ui-serif\",\n    /** iOS `UIFontDescriptorSystemDesignRounded` */\n    rounded: \"ui-rounded\",\n    /** iOS `UIFontDescriptorSystemDesignMonospaced` */\n    mono: \"ui-monospace\",\n  },\n  default: {\n    sans: \"normal\",\n    serif: \"serif\",\n    rounded: \"normal\",\n    mono: \"monospace\",\n  },\n  web: {\n    sans: \"system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif\",\n    serif: \"Georgia, 'Times New Roman', serif\",\n    rounded:\n      \"'SF Pro Rounded', 'Hiragino Maru Gothic ProN', Meiryo, 'MS PGothic', sans-serif\",\n    mono: \"SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace\",\n  },\n});\n","size_bytes":2468}},"version":2}